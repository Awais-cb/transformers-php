<?php

declare(strict_types=1);


namespace Codewithkyrian\Transformers\Models\Pretrained;

use Codewithkyrian\Transformers\Generation\LogitsProcessors\LogitsProcessorList;
use Codewithkyrian\Transformers\Generation\LogitsProcessors\WhisperTimeStampLogitsProcessor;
use Codewithkyrian\Transformers\Generation\Streamers\Streamer;
use Codewithkyrian\Transformers\Models\ModelArchitecture;
use Codewithkyrian\Transformers\OnnxRuntime\InferenceSession;
use Codewithkyrian\Transformers\Tensor\Tensor;
use Codewithkyrian\Transformers\Utils\AutoConfig;
use Codewithkyrian\Transformers\Utils\GenerationConfig;
use Exception;

class WhisperForConditionalGeneration extends WhisperPretrainedModel
{
    public bool $requiresAttentionMask = false;
    public string $mainInputName = 'input_features';

    protected mixed $numDecoderLayers;
    protected mixed $numDecoderHeads;
    protected mixed $decoderDimKv;
    protected mixed $numEncoderLayers;
    protected mixed $numEncoderHeads;
    protected mixed $encoderDimKv;

    public function __construct(
        AutoConfig               $config,
        InferenceSession         $session,
        public InferenceSession  $decoderMergedSession,
        public ModelArchitecture $modelArchitecture,
        public GenerationConfig  $generationConfig
    )
    {
        parent::__construct($config, $session, $modelArchitecture);

        $this->numDecoderLayers = $this->config['decoder_layers'];
        $this->numDecoderHeads = $this->config['decoder_attention_heads'];
        $this->decoderDimKv = $this->config['d_model'] / $this->numDecoderHeads;

        $this->numEncoderLayers = $this->config['encoder_layers'];
        $this->numEncoderHeads = $this->config['encoder_attention_heads'];
        $this->encoderDimKv = $this->config['d_model'] / $this->numEncoderHeads;
    }

    public function generate(
        Tensor               $inputs,
        ?GenerationConfig    $generationConfig = null,
        ?LogitsProcessorList $logitsProcessor = null,
        Tensor               $inputsAttentionMask = null,
        ?Streamer            $streamer = null
    ): array
    {
        $generationConfig = $this->getGenerationConfig($generationConfig);

        // Whisper has additional options for returning timestamps
        $generationConfig['return_timestamps'] ??= false;


        if ($generationConfig['return_timestamps']) {
            $logitsProcessor = new LogitsProcessorList();
            $logitsProcessor->push(new WhisperTimeStampLogitsProcessor($generationConfig));
        }



        if (isset($generationConfig['return_token_timestamps'])) {
            $generationConfig['output_attentions'] = true;
            $generationConfig['return_dict_in_generate'] = true;

            if ($generationConfig['task'] ?? '' === 'translate') {
                trigger_error("Token-level timestamps may not be reliable for task 'translate'.", E_USER_WARNING);
            }

            if (!isset($generationConfig['alignment_heads'])) {
                throw new Exception(
                    "Model generation config has no `alignment_heads`, token-level timestamps not available. " .
                    "See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config."
                );
            }
        }


        $outputs = parent::generate($inputs, $generationConfig, $logitsProcessor, $inputsAttentionMask, $streamer);

        if (isset($generationConfig['return_token_timestamps']) && isset($generationConfig['alignment_heads'])) {
            $outputs['token_timestamps'] = $this->extractTokenTimestamps(
                $outputs,
                $generationConfig['alignment_heads'],
                $generationConfig['num_frames'] ?? null,
            );
        }

        return $outputs;
    }

    /**
     * Calculates token-level timestamps using the encoder-decoder cross-attentions and
     * dynamic time-warping (DTW) to map each output token to a position in the input audio.
     *
     * @param array $generateOutputs Outputs generated by the model
     * @param array $alignmentHeads Alignment heads of the model
     * @param int|null $numFrames Number of frames in the input audio
     * @param float $timePrecision Precision of the timestamps in seconds
     * @return Tensor Tensor containing the timestamps in seconds for each predicted token
     * @throws Exception If the model outputs do not contain cross attentions
     */
    public function extractTokenTimestamps(
        array $generateOutputs,
        array $alignmentHeads,
        int|float|null $numFrames = null,
        float $timePrecision = 0.02
    ): Tensor {
        $numFrames = (int) $numFrames;
        if (!isset($generateOutputs['cross_attentions'])) {
            throw new Exception(
                "Model outputs must contain cross attentions to extract timestamps. " .
                "This is most likely because the model was not exported with `output_attentions=True`."
            );
        }

        $medianFilterWidth = $this->config['median_filter_width'] ?? null;
        if ($medianFilterWidth === null) {
            trigger_error("Model config has no `median_filter_width`, using default value of 7.", E_USER_WARNING);
            $medianFilterWidth = 7;
        }

        $batchedMatrices = array_map(function($batch) use ($numFrames, $alignmentHeads, $medianFilterWidth) {
            // Create a list with `decoder_layers` elements, each a tensor of shape
            // (batch size, attention_heads, output length, input length).
            /** @var Tensor[] $crossAttentions */
            $crossAttentions = [];
            for ($i = 0; $i < $this->config['decoder_layers']; $i++) {
                $crossAttentions[] = Tensor::concat(array_map(fn($x) => $x[$i], $batch), 2);
            }

            $weights = Tensor::stack(array_map(function($alignmentHead) use ($crossAttentions, $numFrames) {
                [$l, $h] = $alignmentHead;
                return $numFrames
                    ? $crossAttentions[$l]->slice(null, $h, null, [0, $numFrames])
                    : $crossAttentions[$l]->slice(null, $h);
            }, $alignmentHeads));
            dd($weights->shape());

            $weights = $weights->permute( 1, 0, 2, 3);


            list($std, $calculatedMean) = std_mean($weights, -2, 0, true);

            // Normalize and smoothen the weights.
            $smoothedWeights = $weights->clone(); // [1, 8, seqLength, 1500]

            for ($a = 0; $a < $smoothedWeights->dims[0]; ++$a) {
                $aTensor = $smoothedWeights[$a]; // [8, seqLength, 1500]

                for ($b = 0; $b < $aTensor->dims[0]; ++$b) {
                    $bTensor = $aTensor[$b]; // [seqLength, 1500]

                    $stdTensor = $std[$a][$b][0]; // [1500]
                    $meanTensor = $calculatedMean[$a][$b][0]; // [1500]

                    for ($c = 0; $c < $bTensor->dims[0]; ++$c) {
                        $cTensor = $bTensor[$c]; // [1500]
                        for ($d = 0; $d < count($cTensor->data); ++$d) {
                            $cTensor->data[$d] = ($cTensor->data[$d] - $meanTensor->data[$d]) / $stdTensor->data[$d];
                        }

                        // Apply median filter.
                        $cTensor->data = medianFilter($cTensor->data, $medianFilterWidth);
                    }
                }
            }

            // Average the different cross-attention heads.
            $matrix = mean($smoothedWeights, 1);
            return $matrix;
        }, $generateOutputs['cross_attentions']);

        $timestampsShape = [count($generateOutputs['sequences']), count($generateOutputs['sequences'][0])];

        $timestamps = new Tensor(null, Tensor::float32, $timestampsShape);

        // Perform dynamic time warping on each element of the batch.
        for ($batchIdx = 0; $batchIdx < $timestampsShape[0]; ++$batchIdx) {
            // NOTE: Since we run only one batch at a time, we can squeeze to get the same dimensions
            // as the python implementation
            $matrix = $batchedMatrices[$batchIdx]->neg()->squeeze_(0);
            list($textIndices, $timeIndices) = dynamicTimeWarping($matrix);

            $diffs = array_map(fn($i) => $textIndices[$i + 1] - $textIndices[$i], range(0, count($textIndices) - 2));
            $jumps = array_map(fn($x) => (bool) $x, array_merge([1], $diffs));

            $jumpTimes = [];
            for ($i = 0; $i < count($jumps); ++$i) {
                if ($jumps[$i]) {
                    $jumpTimes[] = $timeIndices[$i] * $timePrecision;
                    // NOTE: No point in rounding here, since we set to Float32Array later
                }
            }
            $timestamps->buffer()[$batchIdx] = array_merge([0], $jumpTimes);
        }

        return $timestamps;
    }

}