<?php

declare(strict_types=1);


namespace Codewithkyrian\Transformers\Generation\Streamers;

use InvalidArgumentException;

/**
 * Utility class to handle streaming of tokens generated by whisper speech-to-text models.
 *
 * Callback functions are invoked when each of the following events occur:
 *   - A new chunk starts (onChunkStart)
 *   - A new token is generated (onStream)
 *   - A chunk ends (onChunkEnd)
 *   - The stream is finalized (onStreamEnd)
 */
class WhisperTextStreamer extends TextStreamer
{
    protected mixed $onTimestampStartCallback = null;
    protected mixed $onTimestampEndCallback = null;
    protected int $timestampBegin;
    protected float $timePrecision = 0.02;
    protected bool $waitingForTimestamp = false;
    protected float $cumulativeOffset = 0.0;

    public function put(mixed $value): void
    {
        if (count($value) > 1) {
            throw new InvalidArgumentException("WhisperTextStreamer only supports batch size 1");
        }

        $tokens = $value[0]['output_token_ids'];

        if (empty($tokens)) return;

        // Check if the token is a timestamp
        $offset = end($tokens) - $this->timestampBegin;

        if ($offset >= 0) {
            $time = $offset * $this->timePrecision + $this->cumulativeOffset;
            if ($this->waitingForTimestamp) {
                if ($this->onTimestampEndCallback !== null) {
                    call_user_func($this->onTimestampEndCallback, $time);
                }
            } else {
                if ($this->onTimestampStartCallback !== null) {
                    call_user_func($this->onTimestampStartCallback, $time);
                }
            }
            $this->waitingForTimestamp = !$this->waitingForTimestamp;
            $value[0]['output_token_ids'] = [];
        }

        parent::put($value);
    }

    public function onTimestampStart(callable $callback): static
    {
        $this->onTimestampStartCallback = $callback;
        return $this;
    }

    public function onTimestampEnd(callable $callback): static
    {
        $this->onTimestampEndCallback = $callback;
        return $this;
    }

    public function setTimestampBegin(int $timestampBegin): static
    {
        $this->timestampBegin = $timestampBegin;
        return $this;
    }

    public function setTimePrecision(float $timePrecision): static
    {
        $this->timePrecision = $timePrecision;
        return $this;
    }

    public function notifyChunkEnd(float $chunkDuration): void
    {
        $this->cumulativeOffset += $chunkDuration;
    }
}